{"version":3,"sources":["../../src/common/Stream.ts"],"names":[],"mappings":"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","file":"Stream.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nimport { IStringDictionary } from \"./IDictionary\";\nimport { Promise } from \"./Promise\";\nimport { Queue } from \"./Queue\";\nimport { IStreamChunk } from \"./Stream\";\n\nexport interface IStreamChunk<TBuffer> {\n    isEnd: boolean;\n    buffer: TBuffer;\n}\n\nexport class Stream<TBuffer> {\n    private privId: string;\n    private privReaderIdCounter: number = 1;\n    private privStreambuffer: Array<IStreamChunk<TBuffer>>;\n    private privIsEnded: boolean = false;\n    private privReaderQueues: IStringDictionary<Queue<IStreamChunk<TBuffer>>>;\n\n    public constructor(streamId?: string) {\n        this.privId = streamId ? streamId : createNoDashGuid();\n        this.privStreambuffer = [];\n        this.privReaderQueues = {};\n    }\n\n    public get isClosed(): boolean {\n        return this.privIsEnded;\n    }\n\n    public get id(): string {\n        return this.privId;\n    }\n\n    public write = (buffer2: TBuffer): void => {\n        this.throwIfClosed();\n        this.writeStreamChunk({\n            buffer: buffer2,\n            isEnd: false,\n        });\n    }\n\n    public getReader = (): StreamReader<TBuffer> => {\n        const readerId = this.privReaderIdCounter;\n        this.privReaderIdCounter++;\n        const readerQueue = new Queue<IStreamChunk<TBuffer>>();\n        const currentLength = this.privStreambuffer.length;\n        this.privReaderQueues[readerId] = readerQueue;\n        for (let i = 0; i < currentLength; i++) {\n            readerQueue.enqueue(this.privStreambuffer[i]);\n        }\n        return new StreamReader(\n            this.privId,\n            readerQueue,\n            () => {\n                delete this.privReaderQueues[readerId];\n            });\n    }\n\n    public close = (): void => {\n        if (!this.privIsEnded) {\n            this.writeStreamChunk({\n                buffer: null,\n                isEnd: true,\n            });\n            this.privIsEnded = true;\n        }\n    }\n\n    private writeStreamChunk = (streamChunk: IStreamChunk<TBuffer>): void => {\n        this.throwIfClosed();\n        this.privStreambuffer.push(streamChunk);\n        for (const readerId in this.privReaderQueues) {\n            if (!this.privReaderQueues[readerId].isDisposed()) {\n                try {\n                    this.privReaderQueues[readerId].enqueue(streamChunk);\n                } catch (e) {\n                    // Do nothing\n                }\n            }\n        }\n    }\n\n    private throwIfClosed = (): void => {\n        if (this.privIsEnded) {\n            throw new InvalidOperationError(\"Stream closed\");\n        }\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nexport class StreamReader<TBuffer> {\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\n    private privOnClose: () => void;\n    private privIsClosed: boolean = false;\n    private privStreamId: string;\n\n    public constructor(streamId: string, readerQueue: Queue<IStreamChunk<TBuffer>>, onClose: () => void) {\n        this.privReaderQueue = readerQueue;\n        this.privOnClose = onClose;\n        this.privStreamId = streamId;\n    }\n\n    public get isClosed(): boolean {\n        return this.privIsClosed;\n    }\n\n    public get streamId(): string {\n        return this.privStreamId;\n    }\n\n    public read = (): Promise<IStreamChunk<TBuffer>> => {\n        if (this.isClosed) {\n            throw new InvalidOperationError(\"StreamReader closed\");\n        }\n\n        return this.privReaderQueue\n            .dequeue()\n            .onSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\n                if (streamChunk.isEnd) {\n                    this.privReaderQueue.dispose(\"End of stream reached\");\n                }\n\n                return streamChunk;\n            });\n    }\n\n    public close = (): void => {\n        if (!this.privIsClosed) {\n            this.privIsClosed = true;\n            this.privReaderQueue.dispose(\"StreamReader closed\");\n            this.privOnClose();\n        }\n    }\n}\n"]}