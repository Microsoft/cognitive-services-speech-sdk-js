{"version":3,"sources":["../../src/common.browser/OpusRecorder.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,kCAAkC;;AAQlC;IAII,sBAAY,OAAqD;QAAjE,iBAEC;QAEM,WAAM,GAAG,UAAC,OAAqB,EAAE,WAAwB,EAAE,YAAiC;YAC/F,IAAM,aAAa,GAAQ,IAAI,aAAa,CAAC,WAAW,EAAE,KAAI,CAAC,wBAAwB,CAAC,CAAC;YACzF,IAAM,SAAS,GAAG,GAAG,CAAC,CAAC,2GAA2G;YAClI,aAAa,CAAC,eAAe,GAAG,UAAC,kBAAuB;gBACpD,IAAI,YAAY,EAAE;oBACd,IAAM,QAAM,GAAG,IAAI,UAAU,EAAE,CAAC;oBAChC,QAAM,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;oBAClD,QAAM,CAAC,SAAS,GAAG,UAAC,KAAoB;wBACpC,YAAY,CAAC,KAAK,CAAC,QAAM,CAAC,MAAqB,CAAC,CAAC;oBACrD,CAAC,CAAC;iBACL;YACL,CAAC,CAAC;YAEF,KAAI,CAAC,kBAAkB,GAAG;gBACtB,QAAQ,EAAE,aAAa;gBACvB,MAAM,EAAE,WAAW;aACtB,CAAC;YACF,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACnC,CAAC,CAAA;QAEM,0BAAqB,GAAG,UAAC,OAAqB;YACjD,IAAI,KAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,KAAK,KAAK,UAAU,EAAE;gBACvD,KAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;aAC3C;YACD,KAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,UAAC,KAAU,IAAK,OAAA,KAAK,CAAC,IAAI,EAAE,EAAZ,CAAY,CAAC,CAAC;QACrF,CAAC,CAAA;QA5BG,IAAI,CAAC,wBAAwB,GAAG,OAAO,CAAC;IAC5C,CAAC;IA4BL,mBAAC;AAAD,CAlCA,AAkCC,IAAA;AAlCY,oCAAY;AAyCzB;;;;;;;;GAQG","file":"OpusRecorder.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { Stream } from \"../common/Exports\";\nimport { IRecorder } from \"./IRecorder\";\n\n// getting around the build error for MediaRecorder as Typescript does not have a definition for this one.\ndeclare var MediaRecorder: any;\n\nexport class OpusRecorder implements IRecorder {\n    private privMediaResources: IMediaResources;\n    private privMediaRecorderOptions: any;\n\n    constructor(options?: { mimeType: string, bitsPerSecond: number }) {\n        this.privMediaRecorderOptions = options;\n    }\n\n    public record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\n        const mediaRecorder: any = new MediaRecorder(mediaStream, this.privMediaRecorderOptions);\n        const timeslice = 100; // this is in ms - 100 ensures that the chunk doesn't exceed the max size of chunk allowed in WS connection\n        mediaRecorder.ondataavailable = (dataAvailableEvent: any) => {\n            if (outputStream) {\n                const reader = new FileReader();\n                reader.readAsArrayBuffer(dataAvailableEvent.data);\n                reader.onloadend = (event: ProgressEvent) => {\n                    outputStream.write(reader.result as ArrayBuffer);\n                };\n            }\n        };\n\n        this.privMediaResources = {\n            recorder: mediaRecorder,\n            stream: mediaStream,\n        };\n        mediaRecorder.start(timeslice);\n    }\n\n    public releaseMediaResources = (context: AudioContext): void => {\n        if (this.privMediaResources.recorder.state !== \"inactive\") {\n            this.privMediaResources.recorder.stop();\n        }\n        this.privMediaResources.stream.getTracks().forEach((track: any) => track.stop());\n    }\n}\n\ninterface IMediaResources {\n    stream: MediaStream;\n    recorder: any;\n}\n\n/* Declaring this inline to avoid compiler warnings\ndeclare class MediaRecorder {\n    constructor(mediaStream: MediaStream, options: any);\n\n    public state: string;\n\n    public ondataavailable(dataAvailableEvent: any): void;\n    public stop(): void;\n}*/\n"]}