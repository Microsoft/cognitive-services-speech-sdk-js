{"version":3,"sources":["../../src/common.browser/ReplayableAudioNode.ts"],"names":[],"mappings":"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","file":"ReplayableAudioNode.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { AudioStreamFormatImpl } from \"../../src/sdk/Audio/AudioStreamFormat\";\nimport {\n    IAudioStreamNode,\n    IStreamChunk,\n    Promise,\n    PromiseHelper,\n} from \"../common/Exports\";\n\nexport class ReplayableAudioNode implements IAudioStreamNode {\n    private privAudioNode: IAudioStreamNode;\n    private privFormat: AudioStreamFormatImpl;\n    private privBuffers: BufferEntry[] = [];\n    private privReplayOffset: number = 0;\n    private privLastShrinkOffset: number = 0;\n    private privBufferStartOffset: number = 0;\n    private privBufferSerial: number = 0;\n    private privBufferedBytes: number = 0;\n    private privReplay: boolean = false;\n\n    public constructor(audioSource: IAudioStreamNode, format: AudioStreamFormatImpl) {\n        this.privAudioNode = audioSource;\n        this.privFormat = format;\n    }\n\n    public id = (): string => {\n        return this.privAudioNode.id();\n    }\n\n    // Reads and returns the next chunk of audio buffer.\n    // If replay of existing buffers are needed, read() will first seek and replay\n    // existing content, and upoin completion it will read new content from the underlying\n    // audio node, saving that content into the replayable buffers.\n    public read(): Promise<IStreamChunk<ArrayBuffer>> {\n        // if there is a replay request to honor.\n        if (!!this.privReplay && this.privBuffers.length !== 0) {\n            // Find the start point in the buffers.\n            // Offsets are in 100ns increments.\n            // So how many bytes do we need to seek to get the right offset?\n            const offsetToSeek: number = this.privReplayOffset - this.privBufferStartOffset;\n\n            let bytesToSeek: number = Math.round(offsetToSeek * this.privFormat.avgBytesPerSec * 1e-7);\n            if (0 !== (bytesToSeek % 2)) {\n                bytesToSeek++;\n            }\n\n            let i: number = 0;\n\n            while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].buffer.byteLength) {\n                bytesToSeek -= this.privBuffers[i++].buffer.byteLength;\n            }\n\n            const retVal: ArrayBuffer = this.privBuffers[i].buffer.slice(bytesToSeek);\n\n            this.privReplayOffset += (retVal.byteLength / this.privFormat.avgBytesPerSec) * 1e+7;\n\n            // If we've reached the end of the buffers, stop replaying.\n            if (i === this.privBuffers.length - 1) {\n                this.privReplay = false;\n            }\n\n            return PromiseHelper.fromResult<IStreamChunk<ArrayBuffer>>({\n                buffer: retVal,\n                isEnd: false,\n            });\n        }\n\n        return this.privAudioNode.read()\n            .onSuccessContinueWith((result: IStreamChunk<ArrayBuffer>) => {\n                if (result.buffer) {\n\n                    this.privBuffers.push(new BufferEntry(result.buffer, this.privBufferSerial++, this.privBufferedBytes));\n                    this.privBufferedBytes += result.buffer.byteLength;\n                }\n                return result;\n            });\n    }\n\n    public detach(): void {\n        this.privAudioNode.detach();\n        this.privBuffers = undefined;\n    }\n\n    public replay(): void {\n        if (0 !== this.privBuffers.length) {\n            this.privReplay = true;\n            this.privReplayOffset = this.privLastShrinkOffset;\n        }\n    }\n\n    // Shrinks the existing audio buffers to start at the new offset, or at the\n    // beginnign of the buffer closest to the requested offset.\n    // A replay request will start from the last shrink point.\n    public shrinkBuffers(offset: number): void {\n        this.privLastShrinkOffset = offset;\n\n        // Find the start point in the buffers.\n        // Offsets are in 100ns increments.\n        // So how many bytes do we need to seek to get the right offset?\n        const offsetToSeek: number = offset - this.privBufferStartOffset;\n\n        let bytesToSeek: number = Math.round(offsetToSeek * this.privFormat.avgBytesPerSec * 1e-7);\n\n        let i: number = 0;\n\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].buffer.byteLength) {\n            bytesToSeek -= this.privBuffers[i++].buffer.byteLength;\n        }\n        this.privBufferStartOffset = Math.round(offset - ((bytesToSeek / this.privFormat.avgBytesPerSec) * 1e+7));\n\n        this.privBuffers = this.privBuffers.slice(i);\n    }\n}\n\n// Primary use of this class is to help debugging problems with the replay\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\n// the ArrayBuffer directly.\n// tslint:disable-next-line:max-classes-per-file\nclass BufferEntry {\n    public buffer: ArrayBuffer;\n    public serial: number;\n    public byteOffset: number;\n\n    public constructor(buffer: ArrayBuffer, serial: number, byteOffset: number) {\n        this.buffer = buffer;\n        this.serial = serial;\n        this.byteOffset = byteOffset;\n    }\n}\n"]}