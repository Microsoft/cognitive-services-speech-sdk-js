{"version":3,"sources":["../../src/common.browser/MicAudioSource.ts"],"names":[],"mappings":"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","file":"MicAudioSource.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../../src/sdk/Audio/AudioStreamFormat\";\nimport {\n    AudioSourceErrorEvent,\n    AudioSourceEvent,\n    AudioSourceInitializingEvent,\n    AudioSourceOffEvent,\n    AudioSourceReadyEvent,\n    AudioStreamNodeAttachedEvent,\n    AudioStreamNodeAttachingEvent,\n    AudioStreamNodeDetachedEvent,\n    AudioStreamNodeErrorEvent,\n    createNoDashGuid,\n    Deferred,\n    Events,\n    EventSource,\n    IAudioSource,\n    IAudioStreamNode,\n    IStringDictionary,\n    Promise,\n    PromiseHelper,\n    Stream,\n    StreamReader,\n} from \"../common/Exports\";\nimport { IRecorder } from \"./IRecorder\";\n\n// Extending the default definition with browser specific definitions for backward compatibility\ninterface INavigatorUserMedia extends NavigatorUserMedia {\n    webkitGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\n    mozGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\n    msGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\n}\n\nexport class MicAudioSource implements IAudioSource {\n\n    private static readonly AUDIOFORMAT: AudioStreamFormatImpl = AudioStreamFormat.getDefaultInputFormat() as AudioStreamFormatImpl;\n\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\n\n    private privId: string;\n\n    private privEvents: EventSource<AudioSourceEvent>;\n\n    private privInitializeDeferral: Deferred<boolean>;\n\n    private privMediaStream: MediaStream;\n\n    private privContext: AudioContext;\n\n    private readonly privConstraints: MediaStreamConstraints;\n\n    public constructor(private readonly privRecorder: IRecorder, constraints?: MediaStreamConstraints, audioSourceId?: string) {\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n        this.privEvents = new EventSource<AudioSourceEvent>();\n        this.privConstraints = constraints || { audio: true, video: false };\n    }\n\n    public get format(): AudioStreamFormat {\n        return MicAudioSource.AUDIOFORMAT;\n    }\n\n    public turnOn = (): Promise<boolean> => {\n        if (this.privInitializeDeferral) {\n            return this.privInitializeDeferral.promise();\n        }\n\n        this.privInitializeDeferral = new Deferred<boolean>();\n\n        this.createAudioContext();\n\n        const nav = window.navigator as INavigatorUserMedia;\n\n        let getUserMedia = (\n            nav.getUserMedia ||\n            nav.webkitGetUserMedia ||\n            nav.mozGetUserMedia ||\n            nav.msGetUserMedia\n        );\n\n        if (!!nav.mediaDevices) {\n            getUserMedia = (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void => {\n                nav.mediaDevices\n                    .getUserMedia(constraints)\n                    .then(successCallback)\n                    .catch(errorCallback);\n            };\n        }\n\n        if (!getUserMedia) {\n            const errorMsg = \"Browser does not support getUserMedia.\";\n            this.privInitializeDeferral.reject(errorMsg);\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n        } else {\n            const next = () => {\n                this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n                getUserMedia(\n                    this.privConstraints,\n                    (mediaStream: MediaStream) => {\n                        this.privMediaStream = mediaStream;\n                        this.onEvent(new AudioSourceReadyEvent(this.privId));\n                        this.privInitializeDeferral.resolve(true);\n                    }, (error: MediaStreamError) => {\n                        const errorMsg = `Error occurred during microphone initialization: ${error}`;\n                        const tmp = this.privInitializeDeferral;\n                        // HACK: this should be handled through onError callbacks of all promises up the stack.\n                        // Unfortunately, the current implementation does not provide an easy way to reject promises\n                        // without a lot of code replication.\n                        // TODO: fix promise implementation, allow for a graceful reject chaining.\n                        this.privInitializeDeferral = null;\n                        tmp.reject(errorMsg); // this will bubble up through the whole chain of promises,\n                        // with each new level adding extra \"Unhandled callback error\" prefix to the error message.\n                        // The following line is not guaranteed to be executed.\n                        this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\n                    });\n            };\n\n            if (this.privContext.state === \"suspended\") {\n                // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n                // https://github.com/WebAudio/web-audio-api/issues/790\n                this.privContext.resume().then(next, (reason: any) => {\n                    this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\n                });\n            } else {\n                next();\n            }\n        }\n\n        return this.privInitializeDeferral.promise();\n    }\n\n    public id = (): string => {\n        return this.privId;\n    }\n\n    public attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n\n        return this.listen(audioNodeId).onSuccessContinueWith<IAudioStreamNode>(\n            (streamReader: StreamReader<ArrayBuffer>) => {\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n                return {\n                    detach: () => {\n                        streamReader.close();\n                        delete this.privStreams[audioNodeId];\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                        this.turnOff();\n                    },\n                    id: () => {\n                        return audioNodeId;\n                    },\n                    read: () => {\n                        return streamReader.read();\n                    },\n                };\n            });\n    }\n\n    public detach = (audioNodeId: string): void => {\n        if (audioNodeId && this.privStreams[audioNodeId]) {\n            this.privStreams[audioNodeId].close();\n            delete this.privStreams[audioNodeId];\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n        }\n    }\n\n    public turnOff = (): Promise<boolean> => {\n        for (const streamId in this.privStreams) {\n            if (streamId) {\n                const stream = this.privStreams[streamId];\n                if (stream) {\n                    stream.close();\n                }\n            }\n        }\n\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n        this.privInitializeDeferral = null;\n\n        this.destroyAudioContext();\n\n        return PromiseHelper.fromResult(true);\n    }\n\n    public get events(): EventSource<AudioSourceEvent> {\n        return this.privEvents;\n    }\n\n    private listen = (audioNodeId: string): Promise<StreamReader<ArrayBuffer>> => {\n        return this.turnOn()\n            .onSuccessContinueWith<StreamReader<ArrayBuffer>>((_: boolean) => {\n                const stream = new Stream<ArrayBuffer>(audioNodeId);\n                this.privStreams[audioNodeId] = stream;\n\n                try {\n                    this.privRecorder.record(this.privContext, this.privMediaStream, stream);\n                } catch (error) {\n                    this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\n                    throw error;\n                }\n\n                return stream.getReader();\n            });\n    }\n\n    private onEvent = (event: AudioSourceEvent): void => {\n        this.privEvents.onEvent(event);\n        Events.instance.onEvent(event);\n    }\n\n    private createAudioContext = (): void => {\n        if (!!this.privContext) {\n            return;\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n        const AudioContext = ((window as any).AudioContext)\n            || ((window as any).webkitAudioContext)\n            || false;\n\n        if (!AudioContext) {\n            throw new Error(\"Browser does not support Web Audio API (AudioContext is not available).\");\n        }\n\n        this.privContext = new AudioContext();\n    }\n\n    private destroyAudioContext = (): void => {\n        if (!this.privContext) {\n            return;\n        }\n\n        this.privRecorder.releaseMediaResources(this.privContext);\n\n        // This pattern brought to you by a bug in the TypeScript compiler where it\n        // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\n        // https://github.com/Microsoft/TypeScript/issues/11498\n        let hasClose: boolean = false;\n        if (\"close\" in this.privContext) {\n            hasClose = true;\n        }\n\n        if (hasClose) {\n            this.privContext.close();\n            this.privContext = null;\n        } else if (null !== this.privContext && this.privContext.state === \"running\") {\n            // Suspend actually takes a callback, but analogous to the\n            // resume method, it'll be only fired if suspend is called\n            // in a direct response to a user action. The later is not always\n            // the case, as TurnOff is also called, when we receive an\n            // end-of-speech message from the service. So, doing a best effort\n            // fire-and-forget here.\n            this.privContext.suspend();\n        }\n    }\n}\n"]}